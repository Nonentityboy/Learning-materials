### 浏览器缓存


#### 强缓存

浏览器中的缓存作用分为两种情况，一种是需要发送`HTTP请求`，一种是不需要发送。

首先是检查强缓存，这个阶段不需要发送HTTP请求。

如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。
在`HTTP/1.0`和`HTTP/1.1`当中，这个字段是不一样的。在早期，也就是`HTTP/1.0`时期，使用的是`Expires`，而`HTTP/1.1`使用的是`Cache-Control`。
让我们首先来看看Expires。

##### Expires
`Expires`即过期时间，存在于服务端返回的响应头中，
告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:
```js
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源在`2019年11月22号8点41分`过期，过期了就得向服务端发请求。
这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的`HTTP1.1`版本中被抛弃了。

##### Cache-Control
在`HTTP1.1`中，采用了一个非常关键的字段：`Cache-Control`。这个字段也是存在于

它和`Expires`本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是`max-age`。比如这个例子:

```js
Cache-Control:max-age=3600
```

它其实可以组合非常多的指令，完成更多场景的缓存判断, 将一些关键的属性列举如下:
public: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。

private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。
no-store：非常粗暴，不进行任何形式的缓存。
s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。

值得注意的是，当`Expires`和`Cache-Control`同时存在的时候，`Cache-Control`会优先考虑。
当然，还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——`协商缓存`了。





#### 协商缓存
#### 缓存位置