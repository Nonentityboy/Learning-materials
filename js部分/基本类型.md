## JS原始数据类型有哪些？引用数据类型有哪些？

在 JS 中，存在着 7 种原始类型，分别是：(boolean null undefined number string symbol bigint)
* boolean
* null
### null是对象吗？为什么？
结论: null不是对象。
解释: 虽然 `typeof null` 会输出 `object`，但是这只是 JS 存在的一个悠久 Bug。
在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

* undefined
* number
### JS数字类型
JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。

### 0.1+0.2为什么不等于0.3？
0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。
<b>JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。</b>

### JS判断数组中是否包含某个值
方法一：array.indexOf
> 此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。

```js
var arr = [1,2,3,4];
var index = arr.indexOf(3);
console.log(index); // 2
```

方法二：array.includes(searcElement[,fromIndex])
> 此方法判断数组中是否存在某个值，如果存在返回true，否则返回false

```js
var arr=[1,2,3,4];
if(arr.includes(3))
    console.log("存在");
else
    console.log("不存在");
```

方法三：array.find(callback[,thisArg])
> 返回数组中满足条件的第一个元素的值，如果没有，返回undefined

```js
var arr=[1,2,3,4];
var result = arr.find(item =>{
    return item > 3
});
console.log(result);
```

方法四：array.findeIndex(callback[,thisArg])
> 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1]

```js
var arr=[1,2,3,4];
var result = arr.findIndex(item =>{
    return item > 3
});
console.log(result);
```

* string
### '1'.toString()为什么可以调用？
```js
var s = new String('1');
s.toString();
s = null;
```
第一步: 创建String类实例。
第二步: 调用实例方法。
第三步: 执行完方法立即销毁这个实例。

整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。
* symbol
* bigint
### 什么是BigInt?

> BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

### 为什么需要BigInt?
> 在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？

> 这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。

```js
console.log(9999999999999999);  //=>10000000000000000

复制代码同时也会有一定的安全性问题:

9007199254740992 === 9007199254740993;    // → true 居然是true!

// 复制代码如何创建并使用BigInt？
// 要创建BigInt，只需要在数字末尾追加n即可。
console.log( 9007199254740995n );    // → 9007199254740995n	
console.log( 9007199254740995 );     // → 9007199254740996
复制代码另一种创建BigInt的方法是用BigInt()构造函数、
BigInt("9007199254740995");    // → 9007199254740995n
复制代码简单使用如下:
10n + 20n;    // → 30n	
10n - 20n;    // → -10n	
+10n;         // → TypeError: Cannot convert a BigInt value to a number	
-10n;         // → -10n	
10n * 20n;    // → 200n	
20n / 10n;    // → 2n	
23n % 10n;    // → 3n	
10n ** 3n;    // → 1000n	

const x = 10n;	
++x;          // → 11n	
--x;          // → 9n
console.log(typeof x);   //"bigint"
```

### 复制代码值得警惕的点?


BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。


因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。

```js
10 + 10n;    // → TypeError
```

不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。
```js
Math.max(2n, 4n, 6n);    // → TypeError
```

当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。

```
if(0n){//条件判断为false

}
if(3n){//条件为true

}
```

元素都为BigInt的数组可以进行sort。


BigInt可以正常地进行位运算，如|、&、<<、>>和^

其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现，要正式成为规范，其实还有很长的路要走。
我们期待BigInt的光明前途！


引用数据类型(对象Object):
* 普通对象-Object
* 数组对象-Array
* 正则对象-RegExp
* 日期对象-Date
* 数学函数-Math
* 函数对象-Function