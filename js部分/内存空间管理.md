# 内存空间详细图解

某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。

对于下面的递归就会无限制的执行下去，直到超出调用堆栈的实际大小，这个是浏览器定义的。
```js
function foo() {
    foo();
}
foo();
```

![test](http://resource.muyiy.cn/image/2019-07-24-060211.png)

## 栈数据结构

栈的结构就是后进先出**（LIFO）**，如果读过前面两篇文章应该是相当熟悉了。文中使用乒乓球盒子的结构来解释。

处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。

![stack](http://resource.muyiy.cn/image/2019-07-24-060213.jpg)

## JavaScript内存声明周期

* 1、分配你所需要的内存
* 2、使用分配到的内存（读、写）
* 3、不需要时将其释放、归还

JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。


### JS内存空间

JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。

### 内存机制
数据如何存储？
基本数据类型用栈存储，引用数据类型用堆存储。

这样其实是不对的，考虑闭包情况下，假如说变量存在栈中，`函数调用完栈顶空间销毁`，闭包变量不就没了？

> 闭包变量是存在堆内存中的

以下类型存储在栈中：

* boolean
* null
* undefined
* number
* string
* symbol
* bigint

而所有的对象数据类型存放在堆中。
原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。

###  为什么不全部用栈来保存呢？
对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:

```js
function f(a) {
  console.log(a);
}

function func(a) {
  f(a);
}

func(1);
```
