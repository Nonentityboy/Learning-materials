# 内存空间详细图解

某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。

对于下面的递归就会无限制的执行下去，直到超出调用堆栈的实际大小，这个是浏览器定义的。
```js
function foo() {
    foo();
}
foo();
```

![test](http://resource.muyiy.cn/image/2019-07-24-060211.png)

## 栈数据结构

栈的结构就是后进先出**（LIFO）**，如果读过前面两篇文章应该是相当熟悉了。文中使用乒乓球盒子的结构来解释。

处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。

![stack](http://resource.muyiy.cn/image/2019-07-24-060213.jpg)

## 堆数据结构

堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的key-value可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

## 队列


队列是一种先进先出（FIFO）的数据结构，这是事件循环（Event Loop）的基础结构。

![image](http://resource.muyiy.cn/image/2019-07-24-60214.jpg)

## 变量的存放
首先我们应该知道内存中有栈和堆，那么变量应该存放在哪里呢，堆？栈？

1、基本类型 --> 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number 、String、Symbol、bigint

2、引用类型 --> 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做`按引用访问`。

而所有的对象数据类型存放在堆中。
原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。

![image](http://resource.muyiy.cn/image/2019-07-24-060214.png)
在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去栈查找再去堆查找。


## JavaScript内存声明周期

* 1、分配你所需要的内存
* 2、使用分配到的内存（读、写）
* 3、不需要时将其释放、归还

JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，使用`a = null`其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。


### JS内存空间

JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。

### 内存机制
数据如何存储？
基本数据类型用栈存储，引用数据类型用堆存储。

这样其实是不对的，考虑闭包情况下，假如说变量存在栈中，`函数调用完栈顶空间销毁`，闭包变量不就没了？

> 闭包变量是存在`堆内存`中的

就是闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数调用之后为什么闭包还能引用到函数内的变量。

```js
function A() {
  let a = 1
  function B() {
      console.log(a)
  }
  return B
}
```

`闭包的简单定义`：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。


## 内存回收

JavaScript有`自动垃圾收集机制`，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。

`局部变量`和`全局变量`的销毁

* 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
* 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。

以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的

* 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。

* 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。


V8引擎对堆内存中的JS对象进行`分代管理`
* `新生代`：存活周期较短的JS对象，如临时变量、字符串等。
* `老生代`：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

## 垃圾回收算法

对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。

* 引用计数（现代浏览器不再使用）
* 标记清除（常用）

### 引用计数
引用计数算法定义`内存不再使用`的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。

```js
// 创建一个对象person，他有两个指向属性age和name的引用
var person = {
    age: 12,
    name: 'aaaa'
};

person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收

var p = person; 
person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收

p = null;           //原person对象已经没有引用，很快会被回收
```

引用计数有一个致命的问题，那就是`循环引用`

如果两个对象`相互引用`，尽管他们已不再使用，但是`垃圾回收器不会进行回收`，最终可能会导致`内存泄漏`。

```js
function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 

    return "cycle reference!"
}

cycle();
```

> cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器`不再使用`这个算法。

但是IE依旧使用。

```js
var div = document.createElement("div");
div.onclick = function() {
    console.log("click");
};
```
上面的写法很常见，但是上面的例子就是一个`循环引用`。

变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为`div变量可在函数内被访问`，所以循环引用就出现了


### 标记清除（常用）
标记清除算法将`不再使用的对象`定义为`无法到达的对象`。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。

无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。

所以上面的例子就可以正确被垃圾回收处理了。

所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：

```js
email.message = document.createElement("div");
displayList.appendChild(email.message);

// 稍后从displayList中清除DOM元素
displayList.removeAllChildren();
```

上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。


### 内存泄漏
对于持续运行的`服务进程（daemon）`，必须`及时释放不再用到的内存`。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做`内存泄漏（memory leak）`
### 内存泄漏识别方法
*  1、浏览器方法
打开开发者工具，选择 Memory
在右侧的Select profiling type字段里面勾选 timeline
点击左上角的录制按钮。
在页面上进行各种操作，模拟用户的使用情况。
一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。
*  2、命令行方法
使用 Node 提供的 process.memoryUsage 方法。

```js
console.log(process.memoryUsage());

// 输出
{ 
  rss: 27709440,		// resident set size，所有内存占用，包括指令区和堆栈
  heapTotal: 5685248,   // "堆"占用的内存，包括用到的和没用到的
  heapUsed: 3449392,	// 用到的堆的部分
  external: 8772 		// V8 引擎内部的 C++ 对象占用的内存
}
```
判断内存泄漏，以heapUsed字段为准。


## WeakMap
ES6 新出的两种数据结构：`WeakSet` 和 `WeakMap`，表示这是`弱引用`，它们对于值的引用都是`不计入垃圾回收机制`的。

```js
const wm = new WeakMap();
const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // "some information"
```

先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。

思考题：

```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// --> undefined
b.x 	// --> {n: 2}
```
答案已经写上面了，这道题的关键在于

1、`优先级`。`.`的优先级高于`=`

2、赋值操作是`从右到左`