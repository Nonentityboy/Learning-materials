## HTTP
HTTP 协议是个无状态协议，不会保存状态。

### Post 和 Get 的区别

* 副作用和幂等

副作用
指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。

幂等
指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致。
比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。

在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。
Post 多用于副作用，不幂等的场景，例如注册。

* 在技术上说

Get 请求能缓存，Post 不能
Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术
URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
Post 支持更多的编码类型且不对数据类型限制

## 常见状态码：
2XX 成功
> 200 OK，表示从客户端发来的请求在服务器端被正确处理
204 No content，表示请求成功，但响应报文不含实体的主体部分
205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
206 Partial Content，进行范围请求

3XX 重定向
>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
302 found，临时性重定向，表示资源临时被分配了新的 URL
303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

4XX 客户端错误
> 400 bad request，请求报文存在语法错误
401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
403 forbidden，表示对请求资源的访问被服务器拒绝
404 not found，表示在服务器上没有找到请求的资源

5XX 服务器错误
> 500 internal sever error，表示服务器端在执行请求时发生了错误
501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### HTTPS为什么让数据传输更安全？

谈到`HTTPS`, 就不得不谈到与之相对的`HTTP`。HTTP的特性是`明文传输`，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP数据经过`TCP层`，然后经过`WIFI路由器`、`运营商`和`目标服务器`，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的`中间人攻击`。

目的：为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。

`HTTPS`并不是一个新的协议,而是一个`加强版HTTP`。其原理是在`HTTP和TCP`之间建立了一个`中间层`，当`HTTP和TCP`通信时并不是像以前那样直接通信，直接经过了一个`中间层进行加密`，将加密后的数据包传给TCP, 响应的，`TCP必须将数据包解密`，才能传给上面的`HTTP`。这个中间层也叫`安全层`。安全层的核心就是`对数据加解密`。

### `HTTPS的加解密`如何实现

#### 对称加密和非对称加密

`对称加密`是最简单的方式，指的是`加密`和`解密`用的是`同样的密钥`。

`非对称加密`，如果有 `A、 B 两把密钥`。
如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。

#### 加解密过程

接着我们来谈谈`浏览器和服务器进行协商加解密`的过程。
首先，浏览器会给服务器发送一个随机数`client_random`和一个`加密的方法列表`。
服务器接收后给浏览器返回另一个随机数`server_random`和`加密方法`。
现在，两者拥有三样相同的凭证: `client_random`、`server_random`和`加密方法`。
接着用这个`加密方法`将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号。

#### 各自应用的效果
如果用`对称加密`的方式，那么第三方可以在中间获取到`client_random`、`server_random`和`加密方法`，由于这个`加密方法同时可以解密`，所以中间人可以成功`对暗号进行解密`，拿到数据，很容易就将这种加密方式破解了。

既然`对称加密`这么`不堪一击`，我们就来试一试`非对称加密`。
在这种加密方式中，服务器手里有两把钥匙，`一把是公钥`，也就是说每个人都能拿到，是公开的，另`一把是私钥`，这把私钥只有服务器自己知道。
好，现在开始传输。
浏览器把`client_random`和`加密方法列表`传过来，服务器接收到，把`server_random`、`加密方法`和`公钥`传给浏览器。
现在两者拥有相同的`client_random`、`server_random`和`加密方法`。然后浏览器用公钥将`client_random`和`server_random`加密，生成与`服务器通信的暗号`。
这时候由于是`非对称加密，公钥加密过的数据只能用私钥解密`，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。
这难道一定就安全吗？回到非对称加密的定义，`公钥加密的数据可以用私钥解密，私钥加密的数据也可以用公钥解密`

服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的，因此我们暂且不采用这种方案。

#### 对称加密和非对称加密的结合

可以发现，对称加密和非对称加密，单独应用任何一个，都会存在安全隐患。那我们能不能把两者结合，进一步保证安全呢？
其实是可以的，演示一下整个流程：

浏览器向服务器发送`client_random`和`加密方法列表`。
服务器接收到，返回`server_random`、`加密方法`以及`公钥`。
浏览器接收，接着生成另一个随机数`pre_random`,并且用`公钥加密`，传给服务器。(敲黑板！重点操作！)
服务器用私钥解密这个被加密后的`pre_random`。

现在浏览器和服务器有三样相同的凭证:`client_random`、`server_random`和`pre_random`。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。
然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。


`HTTPS`并不是一个新的协议, 它在`HTTP和TCP`的传输中建立了一个`安全层`，利用`对称加密和非对称加密`结合数字证书认证的方式，让传输过程的安全性大大提高。
